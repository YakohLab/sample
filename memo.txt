＝＝＝＝＝ まず、独自のゲームを作成するために必ず知っておいて欲しい情報

Scene (scene.cpp, scene.h)は、画面を表示するために必要な全データを入れたもの
	であり、サーバが作成し、全クライアントに配布する。a. ゲーム全体のデー
	タとb. プレイヤー毎のデータに大別されるが、基本的に全て同じデータが
	配布される。唯一異なるのはidなので、プレイヤー毎に見え方を違えたい場
	合は、idに応じて視点を変えるなどの条件判定を表示関数で対応するしかな
	い。左上にStandaloneやServerを表示している箇所を参照にすればよい。表
	示に必要な全データと言っても、画像ファイルなどを含めてはいけない。ゲー
	ムの時刻が進む都度、全クライアントに送信するのだから、データ量を少な
	くすべきだ。画像などの大きなデータは各PCで個別に配列などに読み込んで
	おき、表示したい画像の番号だけをSceneに含めるのが賢明である。なお、
	画像の表示毎に読み込むと遅くなるので、1度だけ呼び出されるon_realize
	関数の中で、配列に読み込んでおくこと。Sceneのメンバを変更する場合、
	それが送受信されるようにpackScene, receiveSceneも変更する必要がある。
	要素数が可変のデータを含める場合には、送る個数も送らなければ読み出せ
	ないことに注意しよう(packScene, receiveScene参照のこと)。ここさえ間
	違えなければ、弾の数を可変にしてvectorコンテナで扱うこともできるので、
	挑戦しても良い。

InputData (input.cpp, input.h)は、各プレイヤーが入力した情報を格納し、サーバ
	に送付するデータである。キーに様々な動作を割り当てたり、スマホのdrag
	動作やピンチ動作などを検出・送信したい場合などは、自由にメンバを増や
	して構わない。ただし、メンバを変えた場合には、packInput,
	receiveInputを確認すること。サンプルでは固定長なので代入文だけで済ま
	しているが、可変長にした場合はSceneの場合と同様に送受信を工夫する必
	要が生じるので注意されたい。Gtkのキー入力は、即応性がないという問題
	がある。すなわち、同じキーを押し続けても、しばらくは押した瞬間のイベ
	ントが1度発生するだけで、しばらく経ってからキーリピートが働いてイベ
	ントが連続発生するようになる。これはタイピングには便利なのだが、ゲー
	ムには不向きだ。そこで、通常のon_key_press_event,
	on_key_release_eventは使わないようにコメントアウトしてあり、替わりに
	ゲーム時刻毎にcheckInputを呼び出し、その時点で押されているキーに対応
	するイベントを疑似生成している。スマホ入力は簡単に座標だけ入力する関
	数で受け取っているが、ドラッグやピンチなどの操作を使いたければ、
	mySmartphoneの中に状態を持たせ、ドラッグ開始時と終了時の座標を送り付
	けるようにするなど工夫すればいいだろう。

model.cpp, model.hは、判定と動作を行う大事な関数群である。座標を変更すれば移
	動できるし、表示する画像を変更すればダメージを受けたようにも見えるだ
	ろう。対戦中、サーバが全プレイヤー分の処理を行うことに注意されたい。
	この時、処理をプレイヤー毎に逐次動作し判定してしまうと、衝突した際に
	一方がダメージを受けて消滅したら、他方にダメージが行かない、というこ
	とが生じ、プレイヤーの参加順に応じた優先度が与えられることになる。こ
	れでは不公平なので、まず衝突検出だけを全員分行い、次にダメージを与え
	る処理を全員分行い、さらにゲーム終了を全員分行う、というように、不公
	平が生じないような工夫が必要になる。これを想定して、preAction,
	stepPlayer, postActionに分けていて、これらをmanagerがゲーム時刻毎に
	呼び出すようにしている。この雛形をうまく活用して欲しい。

TCP/IP通信ポートについて。デフォルトでは、スマホサーバのポート番号は8888、ゲー
	ムサーバのポート番号は10000にしてあるが、既にそのポート番号が使用中
	の場合は、1つずつ大きなポート番号の使用を試みるようにしてある。その
	ため、同じPC上で複数のプログラムを起動しても、個別のウィンドウにスマ
	ホを接続できるようになっている。デフォルト以外のポート番号を使った場
	合には、その旨がコンソールに表示されるので、参照されたい。
	Smartphone.cpp, Smartphone.hおよびNetwork.cpp, Network.hは触らない方
	が無難です。通信に関わる部分を変更したい場合は、継承クラスである
	mysmartphoneやmynetworkを変更するだけに留めましょう。

スマホへの画像送信について。スマホの操作画面に画像を貼り付けることができます。
	sendImageという関数で任意の画像ファイルを送れるようになっています。
	内部的にはsendPixbufという関数で、スマホの画面サイズにリサイズし、
	jpg圧縮して送信するので、割と軽量に動作します。試しにdrawingAreaのス
	クリーンショットを連続送信してみたところ、1秒間に15回くらいなら送れ
	るようでした。これを試してみたい人は、サーバーモードにして一人遊びす
	ると3フレームに1回送るようになります。(view.cppの200行目あたり参照)

＝＝＝＝＝ 以下は更に内部を知りたい諸君のための情報

Membersは、サーバがクライアントの接続状況を管理するためのもので、送られてき
	たInputを格納しておくのにも使われる。プレイヤー毎のデータは、
	std::mapで保持しているが、主キーはfdであり、参加者idではないことに注
	意。fdというのは、通信接続時に決まるソケットのfile descriptorであり、
	飛び飛びに割り当てられる値である。これをプレイヤー番号に使うのは不便
	なので、ゲームスタート時点で0からidを割り振っている(サーバは常に0番)。

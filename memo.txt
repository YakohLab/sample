＝＝＝＝＝ まず、独自のゲームを作成するために必ず知っておいて欲しい情報
Scene (scene.cpp, scene.h)は、画面を表示するために必要な全データを入れたものであり、サーバが作成し、全クライアントに配布する。
	a. ゲーム全体のデータと
	b. プレイヤー毎のデータ
	に大別されるが、基本的に全て同じデータが配布される。唯一異なるのはidなので、プレイヤー毎に見え方を違えたい場合は、
	idに応じて視点を変えるなどの条件判定を表示関数で対応するしかない。左上にStandaloneやServerを表示している箇所を
	参照にすればよい。
	表示に必要な全データと言っても、画像ファイルなどを含めてはいけない。ゲームの時刻が進む都度、全クライアントに送信する
	のだから、データ量を少なくすべきだ。画像などの大きなデータは各PCで個別に配列などに読み込んでおき、表示したい画像の
	番号だけをSceneに含めるのが賢明である。なお、画像の表示毎に読み込むと遅くなるので、1度だけ呼び出されるon_realize関数
	の中で、配列に読み込んでおくこと。
	Sceneのメンバを変更する場合、それが送受信されるようにpackScene, receiveSceneも変更する必要がある。要素数が可変の
	データを含める場合には、送る個数も送らなければ読み出せないことに注意しよう(packScene, receiveScene参照のこと)。
	ここさえ間違えなければ、弾の数を可変にしてvectorコンテナで扱うこともできるので、挑戦しても良い。

InputData (input.cpp, input.h)は、各プレイヤーが入力した情報を格納し、サーバに送付するデータである。
	キーに様々な動作を割り当てたり、スマホのdrag動作やピンチ動作などを検出・送信したい場合などは、自由にメンバを増やして構わない。
	ただし、メンバを変えた場合には、packInput, receiveInputを確認すること。サンプルでは固定長なので代入文だけで済ましているが、
	可変長にした場合はSceneの場合と同様に送受信を工夫する必要が生じるので注意されたい。
	Gtkのキー入力は、即応性がないという問題がある。すなわち、同じキーを押し続けても、しばらくは押した瞬間のイベントが1度
	発生するだけで、しばらく経ってからキーリピートが働いてイベントが連続発生するようになる。これはタイピングには便利なのだが、
	ゲームには不向きだ。そこで、通常のon_key_press_event, on_key_release_eventは使わないようにコメントアウトしてあり、
	替わりにゲーム時刻毎にcheckInputを呼び出し、その時点で押されているキーに対応するイベントを疑似生成している。
	スマホ入力は簡単に座標だけ入力する関数で受け取っているが、ドラッグやピンチなどの操作を使いたければ、mySmartphoneの中に
	状態を持たせ、ドラッグ開始時と終了時の座標を送り付けるようにするなど工夫すればいいだろう。

model.cpp, model.hは、判定と動作を行う大事な関数群である。座標を変更すれば移動できるし、表示する画像を変更すればダメージを
	受けたようにも見えるだろう。対戦中、サーバが全プレイヤー分の処理を行うことに注意されたい。この時、処理をプレイヤー毎に
	逐次動作し判定してしまうと、衝突した際に一方がダメージを受けて消滅したら、他方にダメージが行かない、ということが生じ、
	プレイヤーの参加順に応じた優先度が与えられることになる。これでは不公平なので、まず衝突検出だけを全員分行い、次にダメージを
	与える処理を全員分行い、さらにゲーム終了を全員分行う、というように、不公平が生じないような工夫が必要になる。これを想定して、
	preAction, stepPlayer, postActionに分けていて、これらをmanagerがゲーム時刻毎に呼び出すようにしている。この雛形を
	うまく活用して欲しい。

TCP/IP通信ポートについて
	デフォルトでは、スマホサーバのポート番号は8888、ゲームサーバのポート番号は10000にしてあるが、既にそのポート番号が使用中
	の場合は、1つずつ大きなポート番号の使用を試みるようにしてある。そのため、同じPC上で複数のプログラムを起動しても、個別の
	ウィンドウにスマホを接続できるようになっている。デフォルト以外のポート番号を使った場合には、その旨がコンソールに表示される
	ので、参照されたい。Smartphone.cpp, Smartphone.hおよびNetwork.cpp, Network.hは触らない方が無難です。通信に関わる
	部分を変更したい場合は、継承クラスであるmysmartphoneやmynetworkを変更するだけに留めましょう。

スマホへの画像送信について
	スマホの操作画面に画像を貼り付けることができます。sendImageという関数で任意の画像ファイルを送れるようになっています。
	内部的にはsendPixbufという関数で、スマホの画面サイズにリサイズし、jpg圧縮して送信するので、割と軽量に動作します。
	試しにdrawingAreaのスクリーンショットを連続送信してみたところ、1秒間に15回くらいなら送れるようでした。これを試して
	みたい人は、サーバーモードにして一人遊びすると3フレームに1回送るようになります。(view.cppの200行目あたり参照)

＝＝＝＝＝ 以下は更に内部を知りたい諸君のための情報

Membersは、サーバがクライアントの接続状況を管理するためのもので、これもfdをキーとしたstd::mapで保持している
	Inputsは、送られてきたInputを格納しておく場所

	内部的に、プレイヤー毎のデータは、std::mapで保持しているが、どのマップもキーはfdであり、参加者idではないことに注意。
	fdというのは、通信接続時に決まるソケットのfile descriptorであり、飛び飛びに割り当てられる値である。これをプレイヤー
	番号に使うのは不便なので、ゲームスタート時点で0からidを割り振っている(サーバは常に0番)。
